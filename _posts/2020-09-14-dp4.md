---
layout: post
title: 📚 <다이내믹 프로그래밍 완전정복> 4️⃣
tags: [DP, Programming, studying]
date: 2020-09-14
---

# CHAPTER 04 다이내믹 프로그래밍 적용 전략

1. 재귀 호출을 사용해 풀이법 작성하기
2. 문제의 난이도와 문제를 해결하는 데 DP나 메모이제이션 사용하여 풀이법 개선하기

## 4.1 세 방법을 차례대로 적용하며 문제 풀기

### 행렬에서 최소 이동 비용 구하기

비용 행렬이 주어졌을 때 행렬의 가장 좌상단 셀에서 가장 우하단 셀로 이동하는 데 드는 최소 비용을 반환하는 함수를 작성해보자.
- 단 아래쪽과 오른쪽으로 한 칸씩만 이동할 수 있다고 가정한다.

### 1. 재귀 호출
재귀 호출로 문제를 풀 때는 큰 문제를 작은 하위 문제를 사용해 정의한 후, 재귀호출을 통해 하위 문제를 해결한다.

```python
def minPathCose(cost, m, n) :
    x = minPathCost(cost, m-1, n)
    y = minPathCost(cost, m, n-1)
    return getMin(x, y) + cost[m][n];
```

위 코드에서 종료 조건을 생각해보자.
1. `m`과 `n` 모두 0인 경우 : 출발지가 목적지인 경우 -> cost[0][0] 리턴
2. `m` == 0 && `n` != 0 : 오른쪽으로만 이동하는 경우, 바로 왼쪽 셀의 최소 이동 비용 + 현제 셀의 비용
3. `m` != 0 && `n` == 0 : 아래로만 이동하는 경우, 발 위 셀의 최소 이동 비용 + 현재 셀의 비용

이 경우에서 1번은 종료조건이지만 2, 3번은 특정한 조건일 뿐이고 종료 조건은 아니다.
종료 조건을 반영하여 코드를 다시 작성해보자.

```python
def getMin(a, b) :
    return a if a < b else b 

def minPathCost(cost, m, n) :
    if m == 0 && n == 0 : return cost[0][0]
    if m == 0 : return minPathCost(cost, 0, n-1) + cost[0][n]
    if n == 0 : return minPathCost(cost, m-1, 0) + cost[m][0]

    x = minPathCost(cost, m-1, n)
    y = minPathCost(cost, m, n-1)
    return getMin(x, y) + cost[m][n];
```

- 문제점 : 동일한 계산을 중복적으로 하게 된다. 재귀호출이므로 메모리도 많이 사용한다.

### 2. 메모 전략
> 한번 호출한 인수에 대한 결과를 저장하는 메모전략을 사용하자!

```python
def getMin(a, b) :
    return a if a < b else b 

def minPathCost(cost, m, n) :
    # 이미 캐싱
    if MEM[m][n] != 0 : return MEM[m][n]

    if m == 0 && n == 0 : return cost[0][0]
    elif m == 0 : return minPathCost(cost, 0, n-1) + cost[0][n]
    elif n == 0 : return minPathCost(cost, m-1, 0) + cost[m][0]
    else :
        x = minPathCost(cost, m-1, n)
        y = minPathCost(cost, m, n-1)
        MEM[m][n] = getMin(x, y) + cost[m][n]
    
    return MEM[m][n]
```

- 재귀 호출은 존재하지만 한번 계산한 하위 문제는 다시 계산하지 않는다.

### 3. 상향식 다이내믹 프로그래밍
```python
def getMin(a, b) :
    return a if a < b else b 

def minPathCost(cost, m, n) :
    # 이미 캐싱
    MEM[0][0] = cose[0][0]

    for j in range (1, N) :
        MEM[0][j] = MEM[0][j-1] + cost[0][j]

    for i in range (1, N) :
        MEM[i][0] = MEM[i-1][0] + cost[i][0]
    
    for i in range(1, M):
        for j in range(1, N) :
            MEM[i][j] = getMin(MEM[i-1][j], MEM[i][j-1]) + cost[i][j];
    
    return MEM[M-1][N-1];
```

## 4.2 다이내믹 프로그래밍을 사용한 문제 해결

### DP의 적용 여부를 가장 확실하게 확인하는 방법
1. 문제가 최적의 하위구조를 가지고 있는가?
2. 하위 문제를 반복해서 계산하고 있는가?

> 어떤 값을 최적화, 최대화, 최소화하거나 경우의 수를 찾는 문제가 최적의 하위 구조를 갖고 있을 때 고려해보자!

### DP로 문제 풀기! 🧘‍♂️
1. DP를 적용할 수 있는 경우인지 확인한다.
2. 점화식 또는 재귀 과정을 정의한다.
    - 문제를 하위 문제를 사용하여 하향식으로 정의 : 시간복잡도는 고려하지 않음
    - 기본 케이스에 대한 답을 정의
    - 종료 조건 추가
3. (선택적) 메모 전략 시도 : 하위 문제의 해답을 캐싱한 후 같은 문제를 풀 때 저장된 값 사용
4. 상향식으로 문제 풀이 도전 : 재귀 호출을 제거하고 기본 케이스에서 출발하는 진행 방향으로 재정의, 필요한 값들만 캐싱