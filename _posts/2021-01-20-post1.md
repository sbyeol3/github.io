---
layout: post
title: ğŸ“š <ì´ê²ƒì´ ì½”ë”© í…ŒìŠ¤íŠ¸ë‹¤> - ê·¸ë˜í”„ ì´ë¡ 
tags: [python, studying, algorithm]
date: 2021-01-20
---

> ì°¸ê³ ìë£Œ : ì´ê²ƒì´ ì½”ë”© í…ŒìŠ¤íŠ¸ë‹¤ (ë‚˜ë™ë¹ˆ ì €)

#  1. ë‹¤ì–‘í•œ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜

\ | ê·¸ë˜í”„ | íŠ¸ë¦¬
:---: | :---: | :---:
ë°©í–¥ì„± | ë°©í–¥ ê·¸ë˜í”„ í˜¹ì€ ë¬´ë°©í–¥ ê·¸ë˜í”„ | ë°©í–¥ ê·¸ë˜í”„
ìˆœí™˜ì„± | ìˆœí™˜ ë° ë¹„ìˆœí™˜ | ë¹„ìˆœí™˜
ë£¨íŠ¸ ë…¸ë“œ ì¡´ì¬ ì—¬ë¶€ | ë£¨íŠ¸ ë…¸ë“œê°€ ì—†ìŒ | ë£¨íŠ¸ ë…¸ë“œê°€ ì¡´ì¬
ë…¸ë“œê°„ ê´€ê³„ì„± | ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ ì—†ìŒ | ë¶€ëª¨ì™€ ìì‹ ê´€ê³„
ëª¨ë¸ì˜ ì¢…ë¥˜ | ë„¤íŠ¸ì›Œí¬ ëª¨ë¸ | ê³„ì¸µ ëª¨ë¸

## ì„œë¡œì†Œ ì§‘í•© (Disjoint Sets)

- ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡° : ì„œë¡œì†Œ ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ„ì–´ì§„ ì›ì†Œë“¤ì˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°
- í•©ì§‘í•©ê³¼ ì°¾ê¸° ì—°ì‚°ìœ¼ë¡œ êµ¬ì„±ëœë‹¤. => `union-find` ìë£Œêµ¬ì¡°
- ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°ë¥¼ êµ¬í˜„í•  ë•ŒëŠ” íŠ¸ë¦¬ ìë£Œêµ¬ì¡° ì´ìš©

1.  í•©ì§‘í•© ì—°ì‚° -> ì„œë¡œ ì—°ê²°ëœ ë‘ ë…¸ë“œ A, B í™•ì¸
    1. Aì™€ Bì˜ ë£¨íŠ¸ ë…¸ë“œ A', B'ë¥¼ ì°¾ìŒ
    2. A'ë¥¼ B'ì˜ ë¶€ëª¨ ë…¸ë“œë¡œ ì„¤ì •
2. ëª¨ë“  í•©ì§‘í•© ì—°ì‚°ì„ ì²˜ë¦¬í•  ë•Œê¹Œì§€ 1ë²ˆ ë°˜ë³µ

### ê¸°ë³¸ì ì¸ ì„œë¡œì†Œ ì§‘í•© ì•Œê³ ë¦¬ì¦˜ ì†ŒìŠ¤ì½”ë“œ

```python
def find_parent(parent, x):
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b :
        parent[b] = a
    else :
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v+1)

for i in range(1, v+1):
    parent[i] = i

for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

print('ê° ì›ì†Œê°€ ì†í•œ ì§‘í•©: ', end = ' ')
for i in range(1, v+1):
    print(find_parent(parent, i), end=' ')

# 1 1 1 1 5 5
```

- ë¬¸ì œì  : find í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„ëŠ” `O(V)`

### ê²½ë¡œ ì••ì¶• ê¸°ë²•ì„ ì ìš©í•˜ì—¬ ê°œì„ í•œ ì†ŒìŠ¤ì½”ë“œ

```python
def find_parent(parent, x):
    if parent[x] != x: # ê²½ë¡œë‹¨ì¶•
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b :
        parent[b] = a
    else :
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v+1)

for i in range(1, v+1):
    parent[i] = i

for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

print('ê° ì›ì†Œê°€ ì†í•œ ì§‘í•©: ', end = ' ')
for i in range(1, v+1):
    print(find_parent(parent, i), end=' ')
```

#### ì„œë¡œì†Œ ì§‘í•© ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„

- ë…¸ë“œì˜ ê°œìˆ˜ Vê°œ, ìµœëŒ€ V-1ê°œì˜ union ì—°ì‚°, Mê°œì˜ find ì—°ì‚°
- O(V+M(1+log_(2-M/V)V))

### ì„œë¡œì†Œ ì§‘í•©ì„ í™œìš©í•œ ì‚¬ì´í´ íŒë³„

1. ê° ê°„ì„ ì€ í™•ì¸í•˜ë©° ë‘ ë…¸ë“œì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ í™•ì¸í•œë‹¤.
   1. ë£¨íŠ¸ ë…¸ë“œê°€ ë‹¤ë¥´ë©´ ë‘ ë…¸ë“œì— ëŒ€í•´ union ì—°ì‚°
   2. ê°™ìœ¼ë©´ ì‚¬ì´í´ ë°œìƒ
2. ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ 1ë²ˆ ë°˜ë³µ

- ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê°„ì„ ì— ë°©í–¥ì„±ì´ ì—†ëŠ” ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œë§Œ ì ìš© ê°€ëŠ¥í•˜ë‹¤.

```python
def find_parent(parent, x):
    if parent[x] != x: # ê²½ë¡œë‹¨ì¶•
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b :
        parent[b] = a
    else :
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v+1)

for i in range(1, v+1):
    parent[i] = i

cycle = False

for i in range(e)
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    else :
        union_parent(parent, a, b)

if cycle : print('ì‚¬ì´í´ ë°œìƒ')
```

## ì‹ ì¥ íŠ¸ë¦¬ (spanning tree)

- ì‹ ì¥ íŠ¸ë¦¬ : í•˜ë‚˜ì˜ ê·¸ë˜í”„ê°€ ìˆì„ ë•Œ ëª¨ë“  ë…¸ë“œë¥¼ í¬í•¨í•˜ë©´ì„œ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¶€ë¶„ ê·¸ë˜í”„
- ëª¨ë“  ë…¸ë“œê°€ í¬í•¨ë˜ê³  ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ -> **íŠ¸ë¦¬**ì˜ ì„±ë¦½ ì¡°ê±´

### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜

- ëŒ€í‘œì ì¸ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ : ì‹ ì¥ íŠ¸ë¦¬ ì¤‘ì—ì„œ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
- ê°€ì¥ ì ì€ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ë…¸ë“œ ì—°ê²°
- ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë¶„ë¥˜

1. ê°„ì„  ë°ì´í„°ë¥¼ ë¹„ìš©ì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
2. ê°„ì„ ì„ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° í˜„ì¬ ê°„ì„ ì´ ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ í™•ì¸
   1. ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨
   2. ë°œìƒí•˜ë©´ í¬í•¨ì‹œí‚¤ì§€ ì•ŠìŒ
3. ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ 2ë²ˆ ë°˜ë³µ

- ìµœì¢…ì ì¸ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ë˜ëŠ” ê°„ì„ ì˜ ê°œìˆ˜ëŠ” `ë…¸ë“œì˜ ê°œìˆ˜ - 1` ê³¼ ê°™ë‹¤.
- ì‹œê°„ ë³µì¡ë„ : ê°„ì„ ì˜ ê°œìˆ˜ê°€ Eê°œì¼ ë•Œ, `O(ElogE)` 
  
#### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ

```python
def find_parent(parent, x):
    if parent[x] != x: # ê²½ë¡œë‹¨ì¶•
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b :
        parent[b] = a
    else :
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v+1)

edges = []
result = 0

for i in range(1, v+1):
    parent[i] = i

for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

edges.sort()

for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)
```

## ìœ„ìƒì •ë ¬

- ìˆœì„œê°€ ì •í•´ì ¸ ìˆëŠ” ì¼ë ¨ì˜ ì‘ì—…ì„ ì°¨ë¡€ëŒ€ë¡œ ìˆ˜í–‰í•´ì•¼ í•  ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜
- ìœ„ìƒì •ë ¬ì´ë€, ë°©í–¥ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œë¥¼ ë°©í–¥ì„±ì— ê±°ìŠ¤ë¥´ì§€ ì•Šë„ë¡ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•˜ëŠ” ê²ƒ
- ì§„ì…ì°¨ìˆ˜ : íŠ¹ì •í•œ ë…¸ë“œë¡œ **ë“¤ì–´ì˜¤ëŠ”** ê°„ì„ ì˜ ê°œìˆ˜

1. ì§„ì…ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ íì— ë„£ìŒ
2. íê°€ ë¹Œ ë•Œê¹Œì§€ ë‹¤ìŒ ê³¼ì • ë°˜ë³µ
   1. íì—ì„œ ì›ì†Œë¥¼ êº¼ë‚´ í•´ë‹¹ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ëŠ” ê°„ì„ ì„ ê·¸ë˜í”„ì—ì„œ ì œê±°
   2. ìƒˆë¡­ê²Œ ì§„ì…ì°¨ìˆ˜ê°€ 0ì´ ëœ ë…¸ë“œë¥¼ íì— ë„£ìŒ

- ëª¨ë“  ì›ì†Œë¥¼ ë°©ë¬¸í•˜ê¸° ì „ì— íê°€ ë¹ˆë‹¤ë©´ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ëŠ” ê²ƒ
- ë‹¤ë§Œ ê¸°ë³¸ì ìœ¼ë¡œ ìœ„ìƒ ì •ë ¬ ë¬¸ì œì—ì„œëŠ” ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ëª…ì‹œí•˜ëŠ” ê²½ìš°ê°€ ë” ë§ìŒ
- ì‹œê°„ ë³µì¡ë„ : `O(V+E)`

```python
from collections import deque

v, e = map(int, input().split())
indegree = [0] * v+1
graph = [[] for i in range(v+1)]

for _ in range(e) :
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1

def topology_sort():
    result = [] # ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰ ê²°ê³¼
    q = deque()

    for i in range(1, v+1) :
        if indegree[i] == 0 : q.append(i)

    while q :
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i] -= 1
            if indegree[i] == 0 :
                q.append(i)

for i in result:
    print(i, end=' ')

topology_sort()
```